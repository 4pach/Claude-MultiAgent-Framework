# 💰 Руководство по подагенту Оптимизатор

## 🎯 Назначение

Подагент **💰 Оптимизатор** отвечает за мониторинг, анализ эффективности и оптимизацию использования MCP серверов в мультиагентной системе. Цель - максимальная продуктивность при минимальных затратах токенов и времени.

## 🧠 Принципы работы

### 🎛️ Основные функции:
1. **Мониторинг производительности** - отслеживание метрик по всем MCP вызовам
2. **Анализ эффективности** - выявление узких мест и неоптимальных паттернов
3. **Кэширование** - управление повторным использованием результатов
4. **Предотвращение дублирования** - обнаружение избыточных запросов
5. **Рекомендации оптимизации** - предложения по улучшению workflow

### ⚡ Критерии оптимизации:
- **Скорость выполнения** - минимизация времени ответа
- **Потребление токенов** - эффективное использование лимитов API
- **Точность результатов** - качество при оптимальных ресурсах
- **Избежание дублирования** - повторное использование данных

## 📊 Система мониторинга

### 🏷️ Формат отчетности:
```
[💰 Оптимизатор] [Тип анализа] Описание рекомендации
```

### 📈 Типы анализа:
- ✅ **Эффективно** - оптимальное использование ресурсов
- ⚠️ **Предупреждение** - потенциальная неэффективность
- 💡 **Рекомендация** - предложение по улучшению
- 🔄 **Дубликат обнаружен** - найден повторный запрос
- 📊 **Статистика** - сводная информация по сессии

## 🛠️ Практические стратегии

### 🗄️ Кэширование результатов

#### Когда кэшировать:
- **Документация API** (Context7) - срок жизни: 2-4 часа
- **Поиск репозиториев** (GitHub) - срок жизни: 24 часа
- **Исследования безопасности** (Exa) - срок жизни: 12 часов
- **Планы проектов** (TaskMaster-AI) - срок жизни: до изменения требований

#### Примеры кэширования:
```
[💰 Оптимизатор] 🔄 ДУБЛИКАТ ОБНАРУЖЕН:
Предыдущий запрос: [🧠 Архитектор → Context7] aiogram.types.Message (2ч 15мин назад)
Использую кэшированный результат
Экономия: 340 токенов, 1.8сек
```

### 🎯 Селективная фильтрация

#### Стратегии узких запросов:
- **Версионная специфичность** - указывать конкретные версии библиотек
- **Тематическая фокусировка** - ограничивать область поиска
- **Языковые фильтры** - поиск только на нужном языке программирования
- **Временные рамки** - актуальные результаты за последний период

#### Примеры оптимизации:
```
Вместо: "aiogram примеры"
Лучше: "aiogram 3.x middleware examples Python 2024"

[💰 Оптимизатор] ✅ Эффективно: узкий запрос сократил результат с 1200 до 280 токенов
```

### 🔗 Объединение запросов

#### Паттерны объединения:
```
Неэффективно:
1. [🧠 Архитектор → Context7] aiogram.Bot.send_message
2. [🧠 Архитектор → Context7] aiogram.Bot.send_photo
3. [🧠 Архитектор → Context7] aiogram.Bot.send_document

Эффективно:
1. [🧠 Архитектор → Context7] aiogram.Bot.send_* methods (message, photo, document)

[💰 Оптимизатор] 💡 Объединение экономит: 560 токенов, 4.2сек (3 запроса → 1)
```

## 📈 Метрики и аналитика

### 🎛️ Ключевые показатели:

#### По MCP серверам:
- **Среднее время ответа** (секунды)
- **Потребление токенов** (за запрос/за сессию)
- **Частота использования** (вызовов в час)
- **Процент успешных запросов** (без ошибок)

#### По подагентам:
- **Эффективность выбора MCP** (соответствие специализации)
- **Объем данных на выходе** (полезность результата)
- **Повторное использование** (процент кэшированных запросов)

#### Общая производительность:
- **Общее время сессии** (от первого до последнего запроса)
- **Суммарное потребление токенов** (по всем серверам)
- **Коэффициент дублирования** (избыточные запросы / общие запросы)

### 📊 Пример отчета производительности:
```
[💰 Оптимизатор] === ОТЧЕТ ПО ЭФФЕКТИВНОСТИ ===

🎯 ЛУЧШИЕ ПРАКТИКИ В СЕССИИ:
• TaskMaster-AI: 95% эффективность планирования (4/4 запроса оптимальны)
• Context7: 80% использование кэша (сэкономлено 780 токенов)
• GitHub: отличная фильтрация (22 результата → ТОП-5)

⚠️ ОБЛАСТИ ДЛЯ УЛУЧШЕНИЯ:
• Exa: 1 избыточный запрос (безопасность уже исследовалась 3ч назад)
• Playwright: долгое выполнение (8.7сек, можно разбить на этапы)

📊 СВОДНАЯ СТАТИСТИКА:
┌─────────────────┬──────────┬─────────┬──────────┬────────────┐
│ Подагент        │ Запросы  │ Токены  │ Время    │ Эффективность │
├─────────────────┼──────────┼─────────┼──────────┼────────────┤
│ 🧭 Менеджер     │ 4        │ 1,680   │ 8.4сек   │ 95%        │
│ 🧠 Архитектор   │ 3        │ 1,020   │ 5.4сек   │ 80%        │
│ 🧪 Инженер      │ 2        │ 1,360   │ 7.0сек   │ 90%        │
│ 🛡️ Критик       │ 1        │ 680     │ 3.7сек   │ 70%        │
└─────────────────┴──────────┴─────────┴──────────┴────────────┘

🏆 ОБЩАЯ ОЦЕНКА: 87% эффективности
💰 ЭКОНОМИЯ: 1,120 токенов, 6.8сек благодаря оптимизации
```

## 🚀 Рекомендации по интеграции

### 🔄 Workflow оптимизации:

1. **Предварительный анализ** - оценка типа задачи перед выбором MCP
2. **Проверка кэша** - поиск существующих результатов
3. **Выполнение запроса** - с мониторингом метрик
4. **Постобработка** - анализ эффективности и кэширование
5. **Рекомендации** - предложения для будущих запросов

### 📋 Чек-лист для подагентов:

#### Перед MCP запросом:
- [ ] Проверил ли я кэш на похожие запросы?
- [ ] Является ли запрос максимально конкретным?
- [ ] Можно ли объединить с другими запросами?
- [ ] Правильно ли выбран MCP сервер для задачи?

#### После MCP ответа:
- [ ] Достаточно ли информации в ответе?
- [ ] Стоит ли кэшировать результат?
- [ ] Можно ли использовать результат для других задач?
- [ ] Требуется ли дополнительная фильтрация?

### 🎯 Специализация по MCP серверам:

| MCP Server | Оптимальный размер запроса | Рекомендуемое кэширование | Специфика |
|------------|----------------------------|---------------------------|-----------|
| **TaskMaster-AI** | Средний (5-15 задач) | До изменения требований | Структурированные планы |
| **Context7** | Узкий (конкретная функция) | 2-4 часа | Документация API |
| **GitHub** | Средний (с фильтрами) | 24 часа | Примеры кода |
| **Exa** | Широкий (исследования) | 12 часов | Аналитика и тренды |
| **SequentialThinking** | Сложный (многоэтапный) | Не кэшировать | Уникальный анализ |
| **Playwright** | Поэтапный (разбивка) | Не кэшировать | Интерактивные тесты |
| **WCGW** | Точечный (одна команда) | 1 час | Системные операции |
| **YouTube-Transcript** | Конкретный (один URL) | 48 часов | Видео контент |

## 🎛️ Настройки и конфигурация

### ⚙️ Параметры оптимизации:

```bash
# Лимиты токенов (настраиваемые)
MAX_TOKENS_PER_REQUEST=1000
MAX_TOKENS_PER_SESSION=5000
WARNING_THRESHOLD=80%

# Временные лимиты
MAX_REQUEST_TIME=10.0s
WARNING_RESPONSE_TIME=5.0s

# Кэширование
CACHE_CONTEXT7_TTL=4h
CACHE_GITHUB_TTL=24h
CACHE_EXA_TTL=12h

# Мониторинг
EFFICIENCY_REPORT_INTERVAL=10_requests
DUPLICATE_DETECTION=true
AUTO_OPTIMIZATION=true
```

### 🔧 Интеграция с Claude Code:

```python
# Пример логики оптимизатора
class MCPOptimizer:
    def __init__(self):
        self.cache = {}
        self.metrics = {}
        self.session_stats = {
            'total_requests': 0,
            'total_tokens': 0,
            'total_time': 0.0,
            'duplicates_prevented': 0
        }
    
    def analyze_request(self, agent, mcp_server, query):
        # Проверка кэша
        cache_key = f"{mcp_server}:{hash(query)}"
        if cache_key in self.cache:
            return self.use_cached_result(cache_key)
        
        # Анализ эффективности запроса
        efficiency_score = self.calculate_efficiency(query)
        if efficiency_score < 0.7:
            return self.suggest_optimization(query)
        
        return {"proceed": True, "optimizations": []}
    
    def log_response(self, mcp_server, tokens, time_taken):
        # Обновление статистики
        self.session_stats['total_requests'] += 1
        self.session_stats['total_tokens'] += tokens
        self.session_stats['total_time'] += time_taken
        
        # Анализ эффективности
        if time_taken > 5.0:
            return f"⚠️ Длительное выполнение: рассмотреть разбивку запроса"
        elif tokens > 800:
            return f"💡 Большой ответ: можно сузить запрос"
        else:
            return f"✅ Эффективно: оптимальное использование ресурсов"
```

## 📝 Заключение

Подагент **💰 Оптимизатор** является ключевым компонентом эффективной мультиагентной системы. Его задача - обеспечить максимальную продуктивность при минимальных затратах ресурсов через:

- **Интеллектуальное кэширование** результатов MCP запросов
- **Предотвращение дублирования** и избыточных операций  
- **Оптимизацию запросов** для получения точных результатов
- **Мониторинг производительности** в реальном времени
- **Рекомендации по улучшению** workflow процессов

Регулярное применение принципов оптимизации позволяет достичь **80-95% эффективности** использования MCP серверов и существенно сократить время выполнения задач.

---

*Создано: 2025-07-11 - Специализированное руководство для подагента 💰 Оптимизатор*